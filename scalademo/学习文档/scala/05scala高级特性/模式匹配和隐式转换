#一、模式匹配
类似于java中的switch case，scala提供了更加强大的match case语法，不仅能匹配变量的值，还可以匹配变量的类型，集合的元素，有值没值。

##1、对变量的匹配
语法格式：
```scala
变量名 match {
	case 值1 => 代码
	case 值2 => 代码
	case _ => 代码
}
```

[见代码](../../../src/main/scala/com/gao/demo/模式匹配/匹配的种类01/MatchDemo.scala)

只要有一个case分支满足了，就不会继续判断下一个case分支了，与java不同的是，java需要break才能停止。

##2、对类型的匹配

语法格式：
```scala
变量类型名 match {
	case 变量类型名1：类型 => 代码
	case 变量类型名2：类型 => 代码
	case _：类型 => 代码
}
```

[见代码](../../../src/main/scala/com/gao/demo/模式匹配/类型匹配1)




##3、样例类（case class）与匹配模式
###3.1、样例类
类似于javabean，即只定义field，会由scala再编译的时候自动提供get和set方法。

主构造函数接收的参数通常不需要使用var或val，Scala会自动使用val修饰。

scala自动为样例类定义了伴生对象和apply方法，该方法接收主构造函数中相同的参数，并返回类case class对象。

[见代码](../../../src/main/scala/com/gao/demo/accompany)



##4、Option与匹配模式：
Option有两种值，some：代表有值和None：代表没值
常用于匹配模式中，用于判断某个变量是否有值，比null值明了。

[见代码](../../../src/main/scala/com/gao/demo/模式匹配/option02)


#二、隐式转换
允许手动指定将A类型的对象转化为B类型的对象（为了调用B的方法或增强A的能力）
核心的就是定义隐式转换函数。与普通函数唯一的语法区别是要以implict开头，并且最好要定义函数返回类型

##1、scala默认会自动使用隐式转换的两种情况
###a、当源类型或目标类型的**伴生对象**里面包含隐式转换函数

当进行转换的时候会自动扫描object中的隐式函数


[见代码](../../../src/main/scala/com/gao/demo/隐式转换/自动引入之伴生类01)



###b、当前程序**作用域内**可以用唯一标识符（唯一的隐式转换函数名）表示的隐式转换函数。

如果隐式转换函数不在上述两种情况下，需要手动使用import引入对应的隐式转换函数

[见代码](../../../src/main/scala/com/gao/demo/隐式转换/) 待补充


##2、加强“原生”类型（比如File类）功能
步骤

1.定义加强类，入参一定是"原生"类型

2.在object定义:隐式转换函数。

3.调用：引入隐式转换，调用“加强方法”

[见代码](../../..//src/main/scala/com/gao/demo/隐式转换/加强原生类型03)

###建议：仅仅在需要使用隐式转换的地方，比如某个函数内，使用import导入隐式转换函数，这样可以缩小隐式转换函数的作用域，避免不需要的隐式转换。

